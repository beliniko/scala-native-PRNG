// to measure how unpradictable a prng is the autocorrelation is used
import prng.XORShift
import prng.LinearCongruentialGenerator
import prng.MersenneTwister
import benchmark.EqualDistribution
import benchmark.unpredictableTest
import prng.Rng
import benchmark.unpredictableTest.autocorrelation
import benchmark.PerfomanceTest.*

import mainargs.{main, arg, ParserForClass, Flag, TokensReader}
import benchmark.PerfomanceTest

object Main {
  type AlgorithmType = "XORShift" | "LCG" | "MT"
  implicit object AlgorithmRead extends TokensReader.Simple[AlgorithmType] {
    def shortName: String = "AlgorithmType"
    def read(str: Seq[String]) = str.toList match {
      case "XORShift" :: Nil => Right("XORShift")
      case "LCG" :: Nil      => Right("LCG")
      case "abc" :: Nil      => Right("LCG")
      case "MT" :: Nil       => Right("MT")
      case _                 => Left("Must be one of XORShift, LCG, MT")
    }
  }

  @main
  final case class Configuration(
      @arg(short = 'r', doc = "The random algorithm to use (XORShift, LCG, MT)")
      rng: AlgorithmType,
      @arg(short = 'l', doc = "The size of the sequence to generate")
      sequenceSize: Int,
      @arg(
        short = 's',
        doc = "The start of the range of random numbers to generate"
      )
      start: Int = 0,
      @arg(
        short = 'e',
        doc = "The end of the range of random numbers to generate"
      )
      end: Int = 100
  ) {
    def getRng: Rng = rng match {
      case "XORShift" => XORShift
      case "LCG"      => LinearCongruentialGenerator
      case "MT"       => MersenneTwister
    }
  }

  def main(args: Array[String]): Unit = {
    val config = ParserForClass[Configuration].constructOrExit(args)
    println(config)

    val start = config.start
    val end = config.end

    {
      val randomSeq = config.getRng.seqOfInt(start, end, config.sequenceSize)
      // println(s"Random numbers generated by ${config.rng}: ${randomSeq.take(50)}")

      println(s"distinct number: ${randomSeq.distinct.size}")

      // val chiSquare = EqualDistribution.calculateChiSquareTest(randomSeq, end - start + 1)
      // println(s"Chi-Square-Test for ${config.rng}: $chiSquare")

      // val autocorrelation = unpredictableTest.autocorrelation(randomSeq,1000)
      // println(s"Autocorrelation for ${config.rng}: $autocorrelation")
      // println("1000")
    }

    // get current memory usage
    // val runtime = Runtime.getRuntime()
    // println(s"Used memory before GC: ${(runtime.totalMemory() - runtime.freeMemory()) / 1024} KB")
    // call GC to free memory
    System.gc()

    // get memory usage after GC
    // println(s"Used memory after GC: ${(runtime.totalMemory() - runtime.freeMemory()) / 1024} KB")

    val runMs = PerfomanceTest.measureRunTime(
      config.getRng,
      10,
      start,
      end,
      config.sequenceSize
    )
    println(s"Average runtime for ${config.rng}: $runMs ms")

    // val memoryUsage = PerfomanceTest.measureMemoryUsage(config.getRng, 1, start, end, config.sequenceSize)

    // val ChiSquareXORShift = EqualDistribution.calculateChiSquareTest(XORShift.seqOfInt(0, 14, 100000), 15)
    // println(s"Chi-Square-Test for XORShift: $ChiSquareXORShift")

    // val autocorrelationXORShift = unpredictableTest.autocorrelation(XORShift.seqOfInt(0, 14, 10000), 1)
    // println(s"Autocorrelation for XORShift: $autocorrelationXORShift")

    // val autocorrelationMersenneTwist = unpredictableTest.autocorrelation(MersenneTwister.seqOfInt(0, 14, 10000), 1)
    // println(s"Autocorrelation for Mersenn-Twister: $autocorrelationMersenneTwist")

    // val randomDouble = MersenneTwister.generateRandomDoubles(15)
    // println(s"Random double generated by MersenneTwister: $randomDouble")
  }
}
